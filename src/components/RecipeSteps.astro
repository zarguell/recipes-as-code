---
const { steps, cookware = [], timers = [] } = Astro.props;

function quantityToNumber(q) {
  // step ingredient quantities come as { type:"fixed", value:{ type:"decimal"|"fraction", ... } }
  if (!q) return null;

  if (q.type === "fixed" && q.value?.type === "decimal" && typeof q.value.value === "number") {
    return q.value.value;
  }

  if (q.type === "fixed" && q.value?.type === "fraction") {
    const num = q.value.num;
    const den = q.value.den;
    if (typeof num === "number" && typeof den === "number" && den !== 0) return num / den;
  }

  return null;
}

function gcd(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);
  while (b) [a, b] = [b, a % b];
  return a || 1;
}

// Convert decimal -> “kitchen friendly” mixed fraction (nearest common denom)
function toNiceFraction(x) {
  const whole = Math.floor(x + 1e-10);
  const frac = x - whole;

  if (frac < 1e-6) return { whole, num: 0, den: 1 };

  const dens = [2, 3, 4, 6, 8, 12, 16];
  let best = { num: 0, den: 1, err: Infinity };

  for (const den of dens) {
    const num = Math.round(frac * den);
    const approx = num / den;
    const err = Math.abs(frac - approx);
    if (err < best.err) best = { num, den, err };
  }

  const g = gcd(best.num, best.den);
  const num = best.num / g;
  const den = best.den / g;

  if (num === den) return { whole: whole + 1, num: 0, den: 1 };
  return { whole, num, den };
}

function formatQty(x) {
  if (!Number.isFinite(x)) return "";
  if (x === 0) return "0";

  const { whole, num, den } = toNiceFraction(x);

  if (num === 0) return String(whole);
  if (whole === 0) return `${num}/${den}`;
  return `${whole} ${num}/${den}`;
}

function renderTimer(timerItem) {
  if (!timerItem) return "timer";

  const quantity = timerItem.duration?.value?.value ?? "";
  let unit = timerItem.unit || "minutes";

  // range packed into unit: minutes|4%minutes
  if (typeof unit === "string" && unit.includes("|")) {
    const [realUnit, rhs] = unit.split("|");
    const m = String(rhs).match(/^(\d+)%/);
    if (m) return `⏱️ ${quantity}-${m[1]} ${realUnit}`;
  }

  return `⏱️ ${quantity} ${unit}`;
}

function formatIngredientHuman(ing) {
  const name = ing?.displayName || ing?.name || "";
  if (!name) return "";

  const qty = ing?.quantity?.value?.value ?? ing?.quantity?.value ?? ing?.quantity;
  const unit = ing?.unit || ing?.units || "";

  // IMPORTANT: ignore preparation notes (often stored separately by parsers)
  // e.g., ing.preparation / ing.note / ing.modifiers — do not append anything.

  const qtyNum = Number(qty);
  const hasQty = Number.isFinite(qtyNum);

  if (!hasQty) return name;
  return `${qtyNum}${unit ? ` ${unit}` : ""} ${name}`;
}

// Keep this function for JSON-LD usage only
function getStepText(step) {
  return (step.items || [])
    .map((item) => {
      if (item.type === "text") return item.value;
      if (item.type === "ingredient") return item.displayName || "";
      return "";
    })
    .join("")
    .trim();
}

function ingredientsUsedInStep(step) {
  const seen = new Set();
  const items = (step.items || []).filter((i) => i.type === "ingredient");
  const result = [];

  for (const i of items) {
    const name = i.displayName || "";
    const base = quantityToNumber(i.itemQuantity); // numeric, for scaling
    const unit = i.itemUnit || "";
    const key = `${name}__${base ?? ""}__${unit}`;
    if (seen.has(key)) continue;
    seen.add(key);
    result.push({ name, base, unit });
  }

  return result;
}
---

<ol class="steps">
  {steps.map((step, idx) => {
    const used = ingredientsUsedInStep(step);

    return (
      <li class="step" data-step-root>
        <input type="checkbox" class="step-checkbox" id={`step-${idx}`} data-step-toggle />
        <label for={`step-${idx}`} class="step-label">
          <div class="step-number">{idx + 1}</div>

          <div class="step-body">
            <p class="step-instruction">
              {step.items.map((item) => {
                if (item.type === "text") return item.value;

                if (item.type === "ingredient")
                  return <code class="tok tok-ing">{formatIngredientHuman(item)}</code>;

                if (item.type === "cookware")
                  return <code class="tok tok-cw">{cookware[item.value]?.name ?? "cookware"}</code>;

                if (item.type === "timer") {
                  const t = timers[item.value];
                  const q = t?.duration?.value?.value ?? "";
                  const u = t?.unit ?? "minutes";
                  return <code class="tok tok-timer">{`${q} ${u}`}</code>;
                }

                return "";
              })}
            </p>

            {used.length > 0 && (
              <div class="step-used">
                {used.map((u) => (
                  <button
                    type="button"
                    class="used-chip"
                    data-chip
                    aria-pressed="false"
                    title="Click to toggle"
                  >
                    <span class="used-name">{u.name}</span>

                    <span
                      class="used-qty"
                      data-role="step-qty"
                      data-base={u.base !== null && u.base !== undefined ? String(u.base) : ""}
                      data-unit={u.unit}
                    >
                      {u.base !== null && u.base !== undefined
                        ? `${formatQty(u.base)}${u.unit ? ` ${u.unit}` : ""}`
                        : ""}
                    </span>
                  </button>
                ))}
              </div>
            )}
          </div>
        </label>
      </li>
    );
  })}
</ol>

<script is:inline>
  // Collapse steps when checked
  document.addEventListener("change", (e) => {
    const cb = e.target?.closest?.("[data-step-toggle]");
    if (!cb) return;

    const root = cb.closest("[data-step-root]");
    if (!root) return;

    root.classList.toggle("collapsed", cb.checked);
  });

  // Toggle ingredient chips (per-step)
  document.addEventListener("click", (e) => {
    const btn = e.target.closest("[data-chip]");
    if (!btn) return;

    const pressed = btn.getAttribute("aria-pressed") === "true";
    btn.setAttribute("aria-pressed", pressed ? "false" : "true");
    btn.classList.toggle("done", !pressed);
  });

  // Apply recipe scale to per-step ingredient chips too (listens to the recipe page scale input)
  (function attachScaling() {
    const scaleInput = document.getElementById("recipeScaleInput");
    if (!scaleInput) return; // not on recipe page

    function gcd(a, b) {
      a = Math.abs(a); b = Math.abs(b);
      while (b) [a, b] = [b, a % b];
      return a || 1;
    }

    function toNiceFraction(x) {
      const whole = Math.floor(x + 1e-10);
      const frac = x - whole;
      if (frac < 1e-6) return { whole, num: 0, den: 1 };

      const dens = [2, 3, 4, 6, 8, 12, 16];
      let best = { num: 0, den: 1, err: Infinity };

      for (const den of dens) {
        const num = Math.round(frac * den);
        const approx = num / den;
        const err = Math.abs(frac - approx);
        if (err < best.err) best = { num, den, err };
      }

      const g = gcd(best.num, best.den);
      const num = best.num / g;
      const den = best.den / g;
      if (num === den) return { whole: whole + 1, num: 0, den: 1 };
      return { whole, num, den };
    }

    function formatQty(x) {
      if (!Number.isFinite(x)) return "";
      if (x === 0) return "0";

      const { whole, num, den } = toNiceFraction(x);
      if (num === 0) return String(whole);
      if (whole === 0) return `${num}/${den}`;
      return `${whole} ${num}/${den}`;
    }

    function applyScale(mult) {
      const els = document.querySelectorAll('[data-role="step-qty"]');
      els.forEach((el) => {
        const rawBase = el.getAttribute("data-base");
        const unit = el.getAttribute("data-unit") || "";
        const base = rawBase ? Number(rawBase) : NaN;
        if (!Number.isFinite(base)) return;

        el.textContent = `${formatQty(base * mult)}${unit ? ` ${unit}` : ""}`;
      });
    }

    function getMult() {
      const mult = Number(scaleInput.value || "1");
      return Number.isFinite(mult) && mult > 0 ? mult : 1;
    }

    scaleInput.addEventListener("input", () => applyScale(getMult()));
    applyScale(getMult());
  })();
</script>

<style>
  .steps {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .step {
    display: grid;
    grid-template-columns: 20px 1fr;
    gap: 0.75rem;
    margin-bottom: 1.25rem;
    align-items: start;
    min-width: 0;
  }

  .step-checkbox {
    appearance: none;
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    margin: 0.35rem 0 0 0;
    border: 2px solid var(--border);
    border-radius: 6px;
    background: var(--surface);
    display: grid;
    place-content: center;
    cursor: pointer;
  }

  .step-checkbox:checked {
    background: var(--accent);
    border-color: var(--accent);
  }

  .step-checkbox:checked::after {
    content: "✓";
    color: white;
    font-weight: 900;
    font-size: 14px;
    line-height: 1;
  }

  .step-label {
    display: grid;
    grid-template-columns: 2.25rem 1fr;
    gap: 0.75rem;
    cursor: pointer;
    min-width: 0;
  }

  .step-number {
    width: 2rem;
    height: 2rem;
    background: var(--accent);
    color: white;
    border-radius: 999px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    margin-top: 0.1rem;
  }

  .step-body {
    min-width: 0;
  }

  .step-instruction {
    color: var(--text);
    line-height: 1.6;
  }

  .step-used {
    margin-top: 0.5rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .used-chip {
    border: 1px solid var(--border);
    background: var(--surface);
    border-radius: 999px;
    padding: 0.25rem 0.6rem;
    display: inline-flex;
    gap: 0.5rem;
    align-items: baseline;
    cursor: pointer;
    max-width: 100%;
  }

  .used-name {
    font-weight: 600;
    color: var(--text);
  }

  .used-qty {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    font-size: 0.9em;
    color: var(--muted);
    opacity: 0.9;
    white-space: nowrap;
  }

  .used-chip.done {
    opacity: 0.45;
    text-decoration: line-through;
  }

  .step.collapsed {
    margin-bottom: 0.5rem;
  }

  .step.collapsed .step-used {
    display: none;
  }

  .step.collapsed .step-instruction {
    opacity: 0.45;
    text-decoration: line-through;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
  }

  .step-instruction :global(.tok) {
    background: var(--surface);
    padding: 0.15rem 0.4rem;
    border-radius: 4px;
    border: 1px solid var(--border);
    font-size: 0.9em;
  }

  .step-instruction :global(.tok.tok-ing) {
    background: var(--surface);
    color: var(--text);
    border-color: var(--border);
    font-weight: 500;
  }

  .step-instruction :global(.tok.tok-cw) {
    background: var(--surface);
    color: var(--accent-2);
    border-color: var(--accent-2);
  }

  .step-instruction :global(.tok.tok-timer) {
    background: var(--surface);
    color: var(--accent);
    border-color: var(--accent);
  }
</style>

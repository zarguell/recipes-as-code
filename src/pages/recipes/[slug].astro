---
import { readdir } from "fs/promises";
import { resolve } from "path";
import { readFileSync } from "fs";
import { Recipe } from "@tmlmt/cooklang-parser";
import yaml from "js-yaml";
import JsonLdSchema from "../../components/JsonLdSchema.astro";
import IngredientList from "../../components/IngredientList.astro";
import RecipeSteps from "../../components/RecipeSteps.astro";
import CookwareList from "../../components/CookwareList.astro";
import CooklangSourceBlock from "../../components/CooklangSourceBlock.astro";
import ThemeToggle from "../../components/ThemeToggle.astro";
import Layout from "../../layouts/Layout.astro";

export async function getStaticPaths() {
  const recipesDir = resolve("recipes");
  const files = await readdir(recipesDir);
  const cookFiles = files.filter((f) => f.endsWith(".cook"));

  return cookFiles.map((file) => ({
    params: { slug: file.replace(".cook", "") },
  }));
}

const { slug } = Astro.params;
const recipePath = resolve("recipes", `${slug}.cook`);
const content = readFileSync(recipePath, "utf-8");

// Extract YAML frontmatter
let frontmatter = {};
let recipeContent = content;

const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
if (frontmatterMatch) {
  try {
    frontmatter = yaml.load(frontmatterMatch[1]) || {};
    recipeContent = frontmatterMatch[2];
  } catch (e) {
    console.error(`Error parsing YAML frontmatter in ${slug}:`, e);
  }
}

let recipe;
let parseError = null;

try {
  recipe = new Recipe(recipeContent);
} catch (error) {
  console.error(`Error parsing recipe ${slug}:`, error.message);
  parseError = error.message;
  recipe = {
    metadata: {},
    ingredients: [],
    sections: [],
    cookware: [],
    timers: [],
  };
}

// Merge frontmatter with parsed metadata - frontmatter takes priority
recipe.metadata = { ...recipe.metadata, ...frontmatter };

const ingredients = recipe.ingredients || [];
const cookwareList = recipe.cookware || [];
const timersList = recipe.timers || [];

// Extract steps from sections
const steps = [];
if (recipe.sections) {
  for (const section of recipe.sections) {
    if (section.content) {
      const sectionSteps = section.content.filter((item: any) => item.type === "step");
      steps.push(...sectionSteps);
    }
  }
}

// Helper to extract text from step items for JSON-LD
function getStepText(items: any[]) {
  if (!items || items.length === 0) return "";

  return items
    .map((item) => {
      if (item.type === "text") return item.value;
      if (item.type === "ingredient") return item.displayName || item.name || "";

      if (item.type === "cookware") {
        const cookwareItem = cookwareList[item.value];
        return cookwareItem?.name || "cookware";
      }

      if (item.type === "timer") {
        const timerItem = timersList[item.value];
        if (!timerItem) return "timer";
        const quantity = timerItem.duration?.value?.value || "";
        const unit = timerItem.unit || "minutes";
        return `${quantity} ${unit}`;
      }

      return "";
    })
    .join("");
}

const imageUrl = recipe.metadata.image?.replace(/^["']|["']$/g, "") || null;
const tags = recipe.metadata.tags || [];
const source = recipe.metadata.source;


// Generate JSON-LD schema
const jsonLd = {
  "@context": "https://schema.org/",
  "@type": "Recipe",
  name: recipe.metadata.title || slug,
  description: recipe.metadata.description || "",
  image: imageUrl,
  prepTime: recipe.metadata["prep-time"] ? `PT${recipe.metadata["prep-time"]}` : null,
  cookTime: recipe.metadata["cook-time"] ? `PT${recipe.metadata["cook-time"]}` : null,
  totalTime: recipe.metadata["total-time"] ? `PT${recipe.metadata["total-time"]}` : null,
  recipeYield: recipe.metadata.servings || null,
  recipeCategory: recipe.metadata.category || null,
  recipeCuisine: recipe.metadata.cuisine || null,
  keywords: tags.join(", "),
  author: { "@type": "Person", name: recipe.metadata.author || "Unknown" },
  recipeIngredient: ingredients.map((ing) => {
    let str = ing.name || "";
    if (ing.quantity?.value?.value !== undefined) {
      const qty = ing.quantity.value.value;
      str = `${qty}${ing.unit ? ` ${ing.unit}` : ""} ${str}`;
    }
    return str;
  }),
  recipeInstructions: steps.map((step: any, idx: number) => ({
    "@type": "HowToStep",
    position: idx + 1,
    text: getStepText(step.items || []),
  })),
};
---

<Layout title={recipe.metadata.title || slug} description={recipe.metadata.description} image={imageUrl}>
  <Fragment slot="theme-toggle">
    <ThemeToggle />
  </Fragment>

  <Fragment slot="head">
    <JsonLdSchema schema={jsonLd} />
  </Fragment>

  <div class="recipe-header">
    <a href={import.meta.env.BASE_URL} class="back-button">‚Üê Back to recipes</a>
    <h1>{recipe.metadata.title || slug}</h1>
    {recipe.metadata.description && <p>{recipe.metadata.description}</p>}

    {tags.length > 0 && (
      <div class="tags">
        {tags.map((tag: string) => (
          <a href={`${import.meta.env.BASE_URL}tags/${tag}/`} class="tag">
            #{tag}
          </a>
        ))}
      </div>
    )}

    {source && (
      <div class="source">
        <div class="source-label">Source:</div>
        <a href={source} target="_blank" rel="noopener noreferrer">{source}</a>
      </div>
    )}

    <div class="recipe-controls" data-recipe-controls>
      <button type="button" class="button secondary" id="recipePrintBtn">üñ®Ô∏è Print</button>
      <button type="button" class="button primary" id="addToShoppingListBtn"
              data-recipe-slug={slug}
              data-recipe-title={recipe.metadata.title || slug}>
        üõí Add to Shopping List
      </button>

      <label class="scale">
        <span class="scale-label">Scale</span>
        <input
          id="recipeScaleInput"
          type="number"
          inputmode="decimal"
          step="0.1"
          min="0.1"
          value="1"
        />
        <span class="scale-suffix">√ó</span>
      </label>
    </div>
  </div>

  <div class="hero-section">
    <div class="recipe-image-container">
      {imageUrl ? (
        <img
          src={imageUrl}
          alt={recipe.metadata.title || slug}
          class="recipe-image"
          onerror="this.style.display='none';this.nextElementSibling.style.display='flex';"
          loading="lazy"
        />
      ) : null}
      <div class="image-fallback" style={imageUrl ? "display: none;" : "display: flex;"}>
        <span class="fallback-icon">üç≥</span>
        <span class="fallback-text">No Image</span>
      </div>
    </div>

    <div class="recipe-meta">
      {recipe.metadata?.servings && (
        <div class="meta-item">
          <div class="meta-label">Servings</div>
          <div class="meta-value">{recipe.metadata.servings}</div>
        </div>
      )}

      {recipe.metadata?.["prep-time"] && (
        <div class="meta-item">
          <div class="meta-label">Prep Time</div>
          <div class="meta-value">{recipe.metadata["prep-time"]}</div>
        </div>
      )}

      {recipe.metadata?.["cook-time"] && (
        <div class="meta-item">
          <div class="meta-label">Cook Time</div>
          <div class="meta-value">{recipe.metadata["cook-time"]}</div>
        </div>
      )}

      {recipe.metadata?.["total-time"] && (
        <div class="meta-item">
          <div class="meta-label">Total Time</div>
          <div class="meta-value">{recipe.metadata["total-time"]}</div>
        </div>
      )}
    </div>
  </div>

  <div class="recipe-content">
    <div class="recipe-column">
      <div class="recipe-section">
        <h2>ü•ò Ingredients</h2>
        <IngredientList ingredients={ingredients} />
      </div>

      {cookwareList.length > 0 && (
        <div class="recipe-section">
          <h2>üç≥ Cookware</h2>
          <CookwareList cookware={cookwareList} />
        </div>
      )}
    </div>

    <div class="recipe-column">
      <div class="recipe-section">
        <h2>üë®‚Äçüç≥ Instructions</h2>
        {steps.length > 0 ? (
          <RecipeSteps steps={steps} cookware={cookwareList} timers={timersList} />
        ) : (
          <p>No instructions found</p>
        )}
      </div>
    </div>
  </div>

  <CooklangSourceBlock slug={slug} text={content} />

  <Fragment slot="scripts">
    <script is:inline>
      const controls = document.querySelector("[data-recipe-controls]");
      if (controls) {
        const printBtn = document.getElementById("recipePrintBtn");
        const scaleInput = document.getElementById("recipeScaleInput");

        // Greatest common divisor for simplifying fractions
        function gcd(a, b) {
          a = Math.abs(a); b = Math.abs(b);
          while (b) [a, b] = [b, a % b];
          return a || 1;
        }

        // Convert decimal -> nice fraction (limited denominators)
        function toNiceFraction(x) {
          // handle whole numbers
          const whole = Math.floor(x + 1e-10);
          const frac = x - whole;

          if (frac < 1e-6) return { whole, num: 0, den: 1 };

          // common kitchen denominators
          const dens = [2, 3, 4, 6, 8, 12, 16];
          let best = { num: 0, den: 1, err: Infinity };

          for (const den of dens) {
            const num = Math.round(frac * den);
            const approx = num / den;
            const err = Math.abs(frac - approx);
            if (err < best.err) best = { num, den, err };
          }

          // simplify
          const g = gcd(best.num, best.den);
          const num = best.num / g;
          const den = best.den / g;

          // handle rounding to next whole (e.g. 15/16 * 16)
          if (num === den) return { whole: whole + 1, num: 0, den: 1 };

          return { whole, num, den };
        }

        function formatQty(x) {
          // show 0 as 0
          if (!Number.isFinite(x)) return "";
          if (x === 0) return "0";

          const { whole, num, den } = toNiceFraction(x);

          if (num === 0) return String(whole);
          if (whole === 0) return `${num}/${den}`;
          return `${whole} ${num}/${den}`;
        }

        function applyScale(mult) {
          const ingredientRoot = document.getElementById("ingredientList");
          if (!ingredientRoot) return;

          const els = ingredientRoot.querySelectorAll('[data-role="qty"]');
          els.forEach((el) => {
            const rawBase = el.getAttribute("data-base");
            const unit = el.getAttribute("data-unit") || "";
            const base = rawBase ? Number(rawBase) : NaN;
            if (!Number.isFinite(base)) return;

            const scaled = base * mult;
            el.textContent = `${formatQty(scaled)}${unit ? ` ${unit}` : ""}`;
          });
        }

        if (printBtn) printBtn.addEventListener("click", () => window.print());

        if (scaleInput) {
          scaleInput.addEventListener("input", () => {
            const mult = Number(scaleInput.value || "1");
            applyScale(Number.isFinite(mult) && mult > 0 ? mult : 1);
          });

          applyScale(Number(scaleInput.value || "1") || 1);
        }

        // Shopping list functionality
        const addToShoppingListBtn = document.getElementById("addToShoppingListBtn");
        if (addToShoppingListBtn) {
          // Extract ingredients data for shopping list
          function getIngredientsForShoppingList() {
            const ingredientElements = document.querySelectorAll('[data-role="qty"]');
            const ingredients = [];

            ingredientElements.forEach(el => {
              const base = el.getAttribute("data-base");
              const unit = el.getAttribute("data-unit") || "";
              const nameEl = el.closest('.ingredient')?.querySelector('.ingredient-name');

              if (nameEl && base !== null && base !== "") {
                ingredients.push({
                  name: nameEl.textContent.trim(),
                  unit: unit,
                  baseQuantity: Number(base)
                });
              }
            });

            return ingredients;
          }

          // Check if this recipe is already in shopping list
          function isRecipeInShoppingList() {
            if (!window.shoppingList) return false;
            return window.shoppingList.isRecipeInList(addToShoppingListBtn.getAttribute('data-recipe-slug'));
          }

          // Update button state
          function updateShoppingListButton() {
            if (isRecipeInShoppingList()) {
              addToShoppingListBtn.textContent = "üõí Remove from Shopping List";
              addToShoppingListBtn.classList.remove("primary");
              addToShoppingListBtn.classList.add("secondary");
            } else {
              addToShoppingListBtn.textContent = "üõí Add to Shopping List";
              addToShoppingListBtn.classList.remove("secondary");
              addToShoppingListBtn.classList.add("primary");
            }
          }

          // Initialize button state
          setTimeout(updateShoppingListButton, 100);

          // Handle button click
          addToShoppingListBtn.addEventListener("click", () => {
            if (!window.shoppingList) {
              alert("Shopping list not available. Please refresh the page and try again.");
              return;
            }

            const recipeTitle = addToShoppingListBtn.getAttribute('data-recipe-title');
            const recipeSlug = addToShoppingListBtn.getAttribute('data-recipe-slug');
            const ingredients = getIngredientsForShoppingList();

            if (ingredients.length === 0) {
              alert("No ingredients found for this recipe.");
              return;
            }

            const wasRemoved = window.shoppingList.addRecipe(recipeSlug, recipeTitle, ingredients);
            updateShoppingListButton();

            // Provide feedback
            const message = wasRemoved
              ? "Recipe removed from shopping list!"
              : "Recipe added to shopping list!";

            // Show brief notification
            const notification = document.createElement("div");
            notification.textContent = message;
            notification.style.cssText = `
              position: fixed;
              top: 20px;
              right: 20px;
              background: var(--accent-2);
              color: white;
              padding: 1rem 1.5rem;
              border-radius: 8px;
              z-index: 1000;
              animation: slideIn 0.3s ease;
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
              notification.style.animation = "slideOut 0.3s ease";
              setTimeout(() => notification.remove(), 300);
            }, 2000);
          });
        }
      }
    </script>
  </Fragment>
</Layout>

<style>
  .recipe-header {
    margin-bottom: 1rem;
  }

  /* Recipe controls */
  .recipe-controls {
    display: flex;
    gap: 1rem;
    align-items: center;
    flex-wrap: wrap;
    margin: 1rem 0 0.5rem;
  }

  .recipe-controls .scale {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background: var(--surface);
    border: 2px solid var(--border);
    padding: 0.4rem 0.6rem;
    border-radius: 8px;
  }

  .recipe-controls .scale-label {
    color: var(--muted);
    font-size: 0.9rem;
  }

  .recipe-controls #recipeScaleInput {
    width: 5.5rem;
    border: 0;
    outline: none;
    font-size: 1rem;
    background: transparent;
    color: var(--input-text);
  }

  .recipe-controls .scale-suffix {
    color: var(--muted);
    font-weight: 700;
  }

  /* Image + meta */
  .hero-section {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
    margin: 1.5rem 0;
  }

  @media (max-width: 768px) {
    .hero-section {
      grid-template-columns: 1fr;
    }
  }

  .recipe-image-container {
    display: flex;
    align-items: flex-start;
  }

  .recipe-image {
    max-width: 100%;
    width: 100%;
    height: auto;
    border-radius: 8px;
    object-fit: cover;
  }

  /* Image fallback styling */
  .image-fallback {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    min-height: 300px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    gap: 0.5rem;
  }

  .fallback-icon {
    font-size: 3rem;
    opacity: 0.6;
  }

  .fallback-text {
    font-size: 1rem;
    color: var(--muted);
    font-family: system-ui, sans-serif;
  }

  .recipe-meta {
    display: grid;
    grid-template-columns: 1fr;
    gap: 1rem;
    align-content: start;
  }

  .meta-item {
    background: var(--surface);
    padding: 1rem;
    border-radius: 6px;
    border-left: 3px solid var(--accent);
  }

  .meta-label {
    font-size: 0.85rem;
    color: var(--muted);
    text-transform: uppercase;
    margin-bottom: 0.25rem;
  }

  .meta-value {
    font-weight: bold;
    color: var(--text);
    font-size: 1.25rem;
  }

  .recipe-content {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
    margin: 2rem 0;
  }

  .recipe-column {
    display: flex;
    flex-direction: column;
    gap: 2rem;
  }

  @media (max-width: 968px) {
    .recipe-content {
      grid-template-columns: 1fr;
    }
  }

  .recipe-section {
    background: var(--surface);
    padding: 1.5rem;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .recipe-section h2 {
    color: var(--text);
    border-bottom: 2px solid var(--accent);
    padding-bottom: 0.5rem;
    margin-top: 0;
    margin-bottom: 1rem;
  }

  .tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin: 1rem 0;
  }

  .tag {
    background: var(--surface);
    color: var(--accent-2);
    padding: 0.25rem 0.75rem;
    border-radius: 16px;
    font-size: 0.85rem;
    text-decoration: none;
    border: 1px solid var(--accent-2);
    transition: all 0.2s ease;
  }

  .tag:hover {
    background: var(--accent-2);
    color: white;
    transform: translateY(-1px);
  }

  /* Dark mode tag adjustments */
  html[data-theme="dark"] .tag {
    color: #5db2ff;
    border-color: #5db2ff;
  }

  html[data-theme="dark"] .tag:hover {
    background: #5db2ff;
    color: var(--surface);
  }

  .source {
    background: var(--surface);
    border-left: 3px solid var(--accent);
    padding: 1rem;
    margin: 1rem 0;
    border-radius: 4px;
  }

  .source-label {
    font-size: 0.85rem;
    color: var(--accent);
    font-weight: bold;
    margin-bottom: 0.25rem;
  }

  .source a {
    color: var(--accent-2);
    text-decoration: none;
    transition: color 0.2s ease;
  }

  .source a:hover {
    text-decoration: underline;
    color: var(--accent-2);
    filter: brightness(1.2);
  }

  /* Dark mode source link adjustments */
  html[data-theme="dark"] .source a {
    color: #5db2ff;
  }

  html[data-theme="dark"] .source a:hover {
    color: #7dc3ff;
  }

  /* Back button styling */
  .back-button {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background: var(--accent-2);
    color: white;
    padding: 0.75rem 1.5rem;
    border-radius: 8px;
    text-decoration: none;
    font-weight: bold;
    border: 0;
    cursor: pointer;
    transition: background 0.2s;
    margin-bottom: 1rem;
  }

  .back-button:hover {
    background: #0770c9;
    text-decoration: none;
  }

  html[data-theme="dark"] .back-button {
    background: #5db2ff;
  }

  html[data-theme="dark"] .back-button:hover {
    background: #7dc3ff;
  }

  /* Recipe image responsive styling */
  .recipe-image-container {
    position: relative;
    overflow: hidden;
    border-radius: 8px;
  }

  @media print {
    .recipe-header .back-button,
    .recipe-controls,
    .tags,
    .source {
      display: none !important;
    }

    body {
      background: white;
      color: black;
      padding: 0;
      max-width: none;
    }

    .recipe-section {
      box-shadow: none;
      border: 1px solid #ccc;
    }
  }

  /* Notification animations */
  @keyframes slideIn {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @keyframes slideOut {
    from {
      transform: translateX(0);
      opacity: 1;
    }
    to {
      transform: translateX(100%);
      opacity: 0;
    }
  }
</style>
